import type { Express, Request, Response } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import { trpcMiddleware } from "./trpc";

export async function registerRoutes(app: Express): Promise<Server> {
  // Add tRPC middleware
  app.use('/api/trpc', trpcMiddleware);
  // Get all threads with filtering
  app.get("/api/threads", async (req: Request, res: Response) => {
    const { 
      subreddit, 
      intentType, 
      serpRank, 
      affiliateProgram, 
      search, 
      limit = 10, 
      offset = 0,
      sortBy,
      sortDirection
    } = req.query;
    
    try {
      const threads = await storage.getThreads({
        subreddit: subreddit as string,
        intentType: intentType as string,
        serpRank: serpRank as string,
        affiliateProgram: affiliateProgram as string,
        search: search as string,
        limit: limit ? parseInt(limit as string) : undefined,
        offset: offset ? parseInt(offset as string) : undefined,
        sortBy: sortBy as string,
        sortDirection: (sortDirection as 'asc' | 'desc') || 'desc'
      });
      
      const total = (await storage.getThreads({
        subreddit: subreddit as string,
        intentType: intentType as string,
        serpRank: serpRank as string,
        affiliateProgram: affiliateProgram as string,
        search: search as string
      })).length;
      
      res.json({
        threads,
        total,
        limit: parseInt(limit as string),
        offset: parseInt(offset as string)
      });
    } catch (error) {
      console.error("Error fetching threads:", error);
      res.status(500).json({ message: "Failed to fetch threads" });
    }
  });
  
  // Get a single thread by ID
  app.get("/api/threads/:id", async (req: Request, res: Response) => {
    try {
      const id = parseInt(req.params.id);
      const thread = await storage.getThreadById(id);
      
      if (!thread) {
        return res.status(404).json({ message: "Thread not found" });
      }
      
      res.json(thread);
    } catch (error) {
      console.error("Error fetching thread:", error);
      res.status(500).json({ message: "Failed to fetch thread" });
    }
  });
  
  // Get affiliate programs
  app.get("/api/affiliate-programs", async (_req: Request, res: Response) => {
    try {
      const programs = await storage.getAffiliatePrograms();
      res.json(programs);
    } catch (error) {
      console.error("Error fetching affiliate programs:", error);
      res.status(500).json({ message: "Failed to fetch affiliate programs" });
    }
  });
  
  // Get comment templates
  app.get("/api/comment-templates", async (req: Request, res: Response) => {
    try {
      const type = req.query.type as string;
      let templates;
      
      if (type) {
        templates = await storage.getCommentTemplatesByType(type);
      } else {
        templates = await storage.getCommentTemplates();
      }
      
      res.json(templates);
    } catch (error) {
      console.error("Error fetching comment templates:", error);
      res.status(500).json({ message: "Failed to fetch comment templates" });
    }
  });
  
  // Get crawl history
  app.get("/api/crawl-history", async (_req: Request, res: Response) => {
    try {
      const history = await storage.getCrawlHistory();
      res.json(history);
    } catch (error) {
      console.error("Error fetching crawl history:", error);
      res.status(500).json({ message: "Failed to fetch crawl history" });
    }
  });
  
  // Generate an affiliate comment
  app.post("/api/generate-comment", async (req: Request, res: Response) => {
    try {
      const schema = z.object({
        threadId: z.number(),
        affiliateProgramId: z.number(),
        templateId: z.number()
      });
      
      const { threadId, affiliateProgramId, templateId } = schema.parse(req.body);
      
      // Get the thread, affiliate program, and template
      const thread = await storage.getThreadById(threadId);
      const program = await storage.getAffiliateProgramById(affiliateProgramId);
      const template = await storage.getCommentTemplateById(templateId);
      
      if (!thread || !program || !template) {
        return res.status(404).json({ 
          message: `${!thread ? 'Thread' : !program ? 'Affiliate program' : 'Template'} not found` 
        });
      }
      
      // Generate a comment by replacing placeholders in the template
      let comment = template.template;
      
      // Replace common placeholders
      comment = comment.replaceAll('{{program}}', program.name);
      comment = comment.replaceAll('{{link}}', program.link);
      comment = comment.replaceAll('{{promo_code}}', program.promoCode || '');
      
      // Replace specific placeholders with mock content
      // In a real implementation, these would be generated by an AI
      comment = comment.replaceAll('{{benefit}}', 'it has specialized templates for blog posts, articles, and social media content');
      comment = comment.replaceAll('{{feature}}', 'the Boss Mode plan');
      comment = comment.replaceAll('{{advantage}}', 'write long-form content with AI continuing your thoughts');
      comment = comment.replaceAll('{{reason}}', 'of its versatility and user-friendly interface');
      comment = comment.replaceAll('{{use_case}}', 'blog posts and social media content');
      comment = comment.replaceAll('{{use_case_1}}', 'Blog post outlines');
      comment = comment.replaceAll('{{use_case_2}}', 'Full blog articles');
      comment = comment.replaceAll('{{use_case_3}}', 'Social media captions');
      comment = comment.replaceAll('{{limitation}}', 'the depth of long-form content generation');
      comment = comment.replaceAll('{{drawback}}', 'requires more editing');
      comment = comment.replaceAll('{{improvement}}', 'increased by 200%');
      comment = comment.replaceAll('{{advantage_1}}', 'Specialized templates for your exact content needs');
      comment = comment.replaceAll('{{advantage_2}}', 'High-quality output requiring minimal editing');
      comment = comment.replaceAll('{{advantage_3}}', 'Excellent customer support and regular updates');
      comment = comment.replaceAll('{{plan}}', 'Creator');
      comment = comment.replaceAll('{{price}}', '$49');
      comment = comment.replaceAll('{{result}}', 'have seen a 70% reduction in content creation time');
      comment = comment.replaceAll('{{discount}}', '20% off your first month');
      
      res.json({ comment });
    } catch (error) {
      console.error("Error generating comment:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid request data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to generate comment" });
    }
  });
  
  // Run crawler
  app.post("/api/run-crawler", async (req: Request, res: Response) => {
    try {
      const schema = z.object({
        subreddits: z.array(z.string()).min(1)
      });
      
      const { subreddits } = schema.parse(req.body);
      
      const crawlHistory = await storage.runCrawler(subreddits);
      res.json(crawlHistory);
    } catch (error) {
      console.error("Error running crawler:", error);
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid request data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to run crawler" });
    }
  });

  const httpServer = createServer(app);

  return httpServer;
}
